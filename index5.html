<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>é­”æ³•å¸«æˆ°é¬¥ç³»çµ±</title>

<!-- Part 1: åŸºæœ¬ CSSï¼ˆUI æ¡†æ¶èˆ‡æ’ç‰ˆï¼‰ -->
<style>
  :root{
    --bg-1: #071025;
    --bg-2: #000;
    --panel: rgba(255,255,255,0.04);
    --muted: #bdbdbd;
    --accent: #7dd3fc;
    --success: #4caf50;
    --danger: #ff7043;
    --card-radius: 12px;
  }

  html,body{
    height:100%;
    margin:0;
    font-family: "Noto Sans TC", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    background: radial-gradient(circle at 20% 10%, var(--bg-1) 0%, var(--bg-2) 60%);
    color: #eef2ff;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
  }

  .container{
    max-width:1200px;
    margin:20px auto;
    padding:18px;
  }

  header{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
    margin-bottom:12px;
  }

  header h1{
    margin:0;
    font-size:20px;
    letter-spacing:0.4px;
  }
  header .meta { color:var(--muted); font-size:13px; }

  /* æ§åˆ¶åˆ— */
  .controls{
    display:flex;
    gap:10px;
    align-items:center;
    flex-wrap:wrap;
    margin-bottom:12px;
  }


select {
  background: #111;         /* æ·±è‰²èƒŒæ™¯ï¼Œä¸ç”¨é€æ˜ */
  border:1px solid #444;
  color: #fff;
  padding:6px 8px;
  border-radius:8px;
  width:90px;
}

select option {
  background-color: #111;
  color: #fff;
}


  .controls .group{
    background:var(--panel);
    padding:10px;
    border-radius:10px;
    display:flex;
    gap:8px;
    align-items:center;
  }

  button {
    background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
    color: #fff;
    border:1px solid rgba(255,255,255,0.06);
    padding:8px 12px;
    border-radius:10px;
    cursor:pointer;
    font-weight:600;
    transition: transform .08s ease, box-shadow .08s;
  }
  button:active { transform: translateY(1px); }

  input[type="number"], input[type="text"], select {
    background: rgba(255,255,255,0.03);
    border:1px solid rgba(255,255,255,0.04);
    color: #fff;
    padding:6px 8px;
    border-radius:8px;
    width:90px;
  }
  label { font-size:13px; color:var(--muted); }

  /* ä¸»è¦–è¦ºå€åŸŸ */
  .layout {
    display:grid;
    grid-template-columns: 360px 1fr 320px;
    gap:14px;
  }

  /* å·¦å´ï¼šè¨­å®šé¢æ¿ */
  .panel {
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius: var(--card-radius);
    padding:12px;
    box-shadow: 0 6px 18px rgba(0,0,0,0.5);
  }

  .panel h3 { margin:0 0 8px 0; font-size:14px; }
  .player-row {
    display:flex;
    gap:6px;
    align-items:center;
    margin-bottom:8px;
    padding:6px;
    background: rgba(255,255,255,0.01);
    border-radius:8px;
  }
  .player-row small { color:var(--muted); }

  .players-list {
    max-height:360px;
    overflow:auto;
    margin-top:8px;
    padding-right:6px;
  }

  /* ä¸­é–“ï¼šæˆ°å ´ */
  .battlefield-wrap {
    display:flex;
    flex-direction:column;
    gap:10px;
  }

  .battle-area {
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    height:520px;
    border-radius:12px;
    position:relative;
    overflow:hidden;
    padding:12px;
    display:flex;
    align-items:flex-start;
    justify-content:center;
    flex-wrap:wrap;
    gap:8px;
  }

  /* å–®ä½å¡ç‰‡ */
  .unit {
    width:110px;
    height:130px;
    border-radius:10px;
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border:1px solid rgba(255,255,255,0.04);
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:flex-start;
    padding:8px;
    box-sizing:border-box;
    position:relative;
    transition: transform .12s ease;
  }
  .unit .avatar {
    width:56px; height:56px; border-radius:50%;
    background:linear-gradient(135deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
    display:flex; align-items:center; justify-content:center; font-weight:700;
    margin-bottom:6px;
    border:2px solid rgba(255,255,255,0.03);
  }
  .unit .name { font-size:13px; margin:0; }
  .unit .meta { font-size:11px; color:var(--muted); margin-top:4px; text-align:center; }

  /* HP æ¢ï¼ˆinner å¯¬åº¦æœƒç”± JS å‹•æ…‹æ§åˆ¶ï¼‰ */
  .hpbar { width:100%; height:8px; background:rgba(0,0,0,0.35); border-radius:8px; overflow:hidden; margin-top:6px; }
  .hpbar > i { display:block; height:100%; width:100%; background:linear-gradient(90deg,var(--success), #8bc34a); transition:width .25s ease; }

  /* å³å´ï¼šLog / Stats */
  .log {
    height:260px;
    overflow:auto;
    padding:8px;
    background: rgba(255,255,255,0.01);
    border-radius:10px;
    font-size:13px;
    color:var(--muted);
  }
  .stats {
    margin-top:10px;
    padding:8px;
    background: rgba(255,255,255,0.01);
    border-radius:10px;
    font-size:13px;
    color:var(--muted);
  }

  /* å°è£é£¾ */
  .tag { font-size:12px; padding:4px 8px; border-radius:999px; background:rgba(255,255,255,0.03); color:var(--muted); }
  .flex { display:flex; gap:8px; align-items:center; }
  .space { height:10px; }
  /* responsive */
  @media (max-width: 980px){
    .layout { grid-template-columns: 1fr; }
    .battle-area { height:420px; }







/* =========================================
   PART 2ï¼šæˆ°é¬¥å‹•ç•« CSSï¼ˆé£›è¡Œé­”æ³•ã€çˆ†æ“Šã€å‘½ä¸­ç‰¹æ•ˆï¼‰
   ========================================= */

/* æ”»æ“Šè€…æ®å‹•å‹•ä½œ */
.unit.attack {
  animation: atkShake 0.25s ease;
}
@keyframes atkShake {
  0%   { transform:translateX(0); }
  40%  { transform:translateX(8px) scale(1.04); }
  100% { transform:translateX(0); }
}

/* è¢«æ”»æ“Šè€…äº®ä¸€ä¸‹ */
.unit.hit {
  animation: hitFlash .28s ease;
}
@keyframes hitFlash {
  0% { filter:brightness(1); transform:scale(1); }
  40% { filter:brightness(2); transform:scale(1.06); }
  100% { filter:brightness(1); transform:scale(1); }
}

/* =========================================
   é­”æ³•é£›å½ˆï¼ˆç«çƒ / å†°ç®­ / é›·æ“Šï¼‰
   ========================================= */
.magic-shot {
  position:absolute;
  width:14px; height:14px;
  border-radius:50%;
  pointer-events:none;
  opacity:0;
  transform:scale(0.5);
}

.magic-shot.fire    { background:#ff7043; box-shadow:0 0 12px #ff5722;   }
.magic-shot.ice     { background:#80d8ff; box-shadow:0 0 12px #40c4ff;   }
.magic-shot.thunder { background:#ffeb3b; box-shadow:0 0 16px #ffee58;   }

/* é£›è¡Œè»Œè·¡å‹•ç•« (JS è¨­å®šèµ·é»èˆ‡çµ‚é») */
.magic-shot.fly {
  animation: magicFly .28s linear forwards;
}
@keyframes magicFly {
  0% { opacity:1; transform:scale(.7); }
  100% { opacity:1; transform:scale(1.2); }
}

/* =========================================
   ç‰¹æ•ˆï¼šçˆ†æ“Šæ–‡å­— / Miss é–ƒé¿
   ========================================= */

.float-text {
  position:absolute;
  font-size:14px;
  font-weight:700;
  pointer-events:none;
  opacity:0;
  transform:translateY(0) scale(1);
  animation: floatUp 0.8s ease-out forwards;
}

.float-text.crit { color:#ffeb3b; text-shadow:0 0 8px #ffee58; }
.float-text.miss { color:#90caf9; text-shadow:0 0 8px #42a5f5; }

@keyframes floatUp {
  0%   { opacity:0; transform:translateY(0) scale(0.4); }
  20%  { opacity:1; transform:translateY(-6px) scale(1.1); }
  100% { opacity:0; transform:translateY(-20px) scale(1); }
}

/* =========================================
   ç¯„åœé­”æ³•ï¼šé›·æ“Šçˆ†å…‰
   ========================================= */
.aoe-flash {
  position:absolute;
  left:0; top:0;
  width:100%; height:100%;
  background: radial-gradient(circle, rgba(255,255,0,0.25), transparent 70%);
  opacity:0;
  pointer-events:none;
  animation: aoeFlash .4s ease-out forwards;
}

@keyframes aoeFlash {
  0%   { opacity:0; }
  30%  { opacity:0.7; }
  100% { opacity:0; }
}

/* =========================================
   Buff / Debuff å…‰åœˆ
   ========================================= */
.buff-circle {
  position:absolute;
  bottom:-6px; left:50%;
  width:46px; height:8px;
  border-radius:50%;
  transform:translateX(-50%);
  background: rgba(100,181,246,0.45);
  box-shadow:0 0 10px #64b5f6;
  pointer-events:none;
  opacity:0;
}

.buff-circle.show {
  opacity:1;
  animation: buffPulse 1.2s ease-in-out infinite;
}

@keyframes buffPulse {
  0% { transform:translateX(-50%) scale(.8); opacity:.6; }
  50% { transform:translateX(-50%) scale(1); opacity:1; }
  100% { transform:translateX(-50%) scale(.8); opacity:.6; }
}

  }
</style>
</head>
<body>
  <div class="container">
    <header>
      <div>
<div>
    <button onclick="window.location.href='index.html'" 
          style="background:#222244; color:#ffd700; border:1px solid #ffd700; 
                 padding:10px 20px; border-radius:8px; font-weight:bold; cursor:pointer;">
    é­”æ³•è­°æœƒ
  </button>
</div>
        <h2>ã€é­”æ³•å¸«æˆ°é¬¥ç³»çµ±ã€‘</h2>
        <div class="meta">æˆ°é¬¥ç³»çµ±è¨­ç½®</div>
      </div>

      <div class="meta">æç¤ºï¼šå…ˆæŒ‰ã€Œæ–°å¢ç©å®¶ã€å»ºç«‹ç©å®¶ï¼Œå†æŒ‰ã€Œé–‹å§‹æˆ°é¬¥ã€</div>
    </header>

    <div class="controls">
      <div class="group">
<button id="btnAdd">æ–°å¢ç©å®¶</button>
<button id="btnRemove">åˆªé™¤ç©å®¶</button>
      </div>

      <div class="group">
        <label for="strategy">æ”»æ“Šç­–ç•¥</label>
        <select id="strategy">
          <option value="random">éš¨æ©Ÿæ”»æ“Š</option>
          <option value="lowestHP">æ”»æ“Šè¡€é‡æœ€ä½</option>
          <option value="highestThreat">æ”»æ“Šå¨è„…æœ€é«˜</option>
        </select>
      </div>

      <div class="group">
        <label for="maxTurns">å›åˆä¸Šé™</label>
        <input type="number" id="maxTurns" value="50" min="10" max="1000" />
      </div>

      <div class="group">
        <label>éšŠä¼æ•¸(èª¿æ•´éœ€è¦é‡æ–°åˆªé™¤èˆ‡æ–°å¢ç©å®¶)</label>
        <select id="teamCount">
          <option value="2">2</option>
          <option value="3">3</option>
          <option value="4">4</option>
          <option value="5">5</option>
          <option value="6">6</option>
          <option value="7">7</option>
          <option value="8">8</option>
          <option value="9">9</option>
        </select>
      </div>

      <div class="group">
        <button id="btnStart" onclick="startBattle()">é–‹å§‹æˆ°é¬¥</button>
        <button onclick="stopBattle()">åœæ­¢</button>
      </div>
    </div>

    <div class="layout">
      <!-- å·¦å´ï¼šç©å®¶è¨­å®šé¢æ¿ -->
      <section class="panel">
        <h3>ç©å®¶è¨­å®š</h3>
        <div>
          <small>æ¯ä½ç©å®¶åªéœ€å¡«å¯«ï¼šé­”æ³•æŒ‡æ•¸ï¼ˆMagic Indexï¼‰èˆ‡ åŠ æ¬Šï¼ˆWeightï¼‰</small>
        </div>
        <div class="players-list" id="playersInput">
          <!-- JS å‹•æ…‹æ’å…¥ player-row -->
        </div>
        <div class="space"></div>
        <div class="flex">
          <button onclick="autoFillDemo(6)">å¿«é€Ÿç¤ºç¯„ (6 äºº)</button>
          <button onclick="autoFillDemo(12)">å¿«é€Ÿç¤ºç¯„ (12 äºº)</button>
        </div>
      </section>

      <!-- ä¸­é–“ï¼šæˆ°å ´ -->
      <main class="battlefield-wrap">
        <h3 style="margin:0 0 6px 0">æˆ°å ´</h3>
        <div class="battle-area" id="battleArea">
          <!-- JS å‹•æ…‹æ’å…¥ unit å¡ç‰‡ -->
        </div>

        <div style="display:flex; gap:8px; justify-content:space-between; align-items:center;">
          <div class="tag">ç©å®¶æ•¸ï¼š<span id="lblCount">0</span></div>
          <div class="tag">ç‹€æ…‹ï¼š<span id="lblState">ç­‰å¾…é–‹å§‹</span></div>
          <div class="tag">å›åˆï¼š<span id="lblTurn">0</span></div>
        </div>
      </main>

      <!-- å³å´ï¼šæˆ°é¬¥è¨˜éŒ„èˆ‡çµ±è¨ˆ -->
      <aside>
        <div class="panel log" id="logBox"></div>
        <div class="stats" id="statBox">
          <h4 style="margin-top:0">æˆ°é¬¥çµ±è¨ˆ</h4>
          <div id="statContent">å°šæœªé–‹å§‹</div>
        </div>
      </aside>
    </div>

    <footer style="margin-top:14px; color:var(--muted); font-size:13px;">
      ä¸‹ä¸€æ­¥ï¼šPart 2ï¼ˆå‹•ç•« CSSï¼‰èˆ‡ Part 3/4ï¼ˆæˆ°é¬¥æ ¸å¿ƒèˆ‡å®Œæ•´ JSï¼‰æˆ‘æœƒæ¥è‘—è²¼ä¸Š â€”â€” è‹¥ä½ æƒ³æˆ‘å¯ä»¥ç›´æ¥æŠŠå‰©ä¸‹çš„éƒ½åˆä½µæˆä¸€å€‹å–®ä¸€ HTML æª”æ¡ˆã€‚
    </footer>
  </div>


<script>

/* ===========================
   PART 3+4 å®Œæ•´ JS æ•´åˆç‰ˆ
   åŒ…å«ï¼šåˆå§‹åŒ–å±¬æ€§ã€æŠ€èƒ½ç³»çµ±ã€
         æˆ°é¬¥è¿´åœˆã€å‹•ç•«ã€çµ±è¨ˆ
   å°æ‡‰ DOM å…ƒç´ ï¼šPart1 çš„ ID
   =========================== */

(() => {
  // DOM hooks (ä¾ Part1)
  const playersInput = document.getElementById("playersInput");
  const battleArea = document.getElementById("battleArea");
  const lblCount = document.getElementById("lblCount");
  const lblState = document.getElementById("lblState");
  const lblTurn = document.getElementById("lblTurn");
  const logBox = document.getElementById("logBox");
  const statBox = document.getElementById("statBox");
  const strategySelect = document.getElementById("strategy");
  const maxTurnsInput = document.getElementById("maxTurns");
  const teamCountSelect = document.getElementById("teamCount");
  const btnAdd = document.getElementById("btnAdd");
  const btnRemove = document.getElementById("btnRemove");
  const btnStart = document.getElementById("btnStart");

  // state
  let playerCount = 0;
  let players = [];
  let simInterval = null;
  let currentTurn = 0;
  let running = false;

  // utility
  function $(id) { return document.getElementById(id); }
  function rand(min, max){ return Math.random()*(max-min)+min; }
  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
  function now() { return new Date().toLocaleTimeString(); }

  // ----------------------------
  // add / remove players in UI
  // ----------------------------
  window.addPlayer = addPlayer;
  window.removePlayer = removePlayer;
  window.autoFillDemo = autoFillDemo;

  function addPlayer(defaultMagic = Math.floor(rand(80,160)), defaultWeight = (1+Math.random().toFixed(2))) {
    const id = playerCount;
    const row = document.createElement("div");
    row.className = "player-row";
    row.id = `playerRow${id}`;

    // team options based on current teamCount
    const teamOptions = (() => {
      const teams = Number(teamCountSelect.value || 2);
      let html = `<select id="team${id}">`;
      for(let t=1;t<=teams;t++) html += `<option value="${t}">${t}</option>`;
      html += `</select>`;
      return html;
    })();

    row.innerHTML = `
      <div style="width:34px;"><small>${id+1}</small></div>
      <div style="flex:1">
        éšŠä¼: ${teamOptions}
        é­”æ³•æŒ‡æ•¸: <input id="magi${id}" type="number" value="${defaultMagic}" />
        åŠ æ¬Š: <input id="wei${id}" type="number" step="0.01" value="${defaultWeight}" />
      </div>
    `;
    playersInput.appendChild(row);
    playerCount++;
    updateCountLabel();
    return id;
  }

  function removePlayer(){
    if(playerCount<=0) return;
    playerCount--;
    const row = document.getElementById(`playerRow${playerCount}`);
    if(row) row.remove();
    updateCountLabel();
  }

  function autoFillDemo(n){
    // clear current
    while(playerCount>0) removePlayer();
    // set team count to 2 by default if many players
    if(n>12) teamCountSelect.value = "3";
    for(let i=0;i<n;i++){
      addPlayer(Math.floor(rand(80,160)), (1 + Math.random()).toFixed(2));
    }
  }

  function updateCountLabel(){
    lblCount.innerText = playerCount;
  }

  // ----------------------------
  // Balance formulas & init
  // ----------------------------
  function initPlayersFromUI(){
    players = [];
    battleArea.innerHTML = "";
    statBox.innerHTML = "<h4 style='margin-top:0'>æˆ°é¬¥çµ±è¨ˆ</h4><div id='statContent'>å°šæœªé–‹å§‹</div>";
    logBox.innerHTML = "";

    const teamCount = Number(teamCountSelect.value || 2);

    for(let i=0;i<playerCount;i++){
      const magic = Number($(`magi${i}`).value) || 100;
      const weight = Number($(`wei${i}`).value) || 1.0;
      const team = Number($(`team${i}`) ? $(`team${i}`).value : ((i%teamCount)+1));
      // base
      const base = magic * weight;

      // Balanced formulas (ä½ è¦æ±‚çš„)
      const maxHP = Math.max(30, Math.floor(magic * (20 + Math.random() * 10))); // HP = magic * 20~30
      const ATK = base * (0.8 + Math.random()*0.4) * 1.5; // ATK = magic*weight*(0.8~1.2)*1.5
      const DEF = base * (0.5 + Math.random()*0.4);     // DEF = magic*weight*(0.5~0.9)
      const SPD = weight * (30 + Math.random()*30);     // SPD = weight * 30~60
      const CRI = clamp(0.05 + Math.random()*0.10, 0.01, 0.35); // 5~15%
      const EVA = clamp(0.03 + Math.random()*0.07, 0.0, 0.2);   // 3~10%

      const p = {
        id: i,
        name: `P${i+1}`,
        team,
        magicIndex: magic,
        weight,
        maxHP,
        hp: maxHP,
        ATK,
        DEF,
        SPD,
        CRI,
        EVA,
        alive: true,
        // runtime stats
        totalDamage: 0,
        critCount: 0,
        hitsReceived: 0,
        actions: 0,
        debuffs: { slowTurns:0 },
        buffs: { shield:0 }, // shield value (damage reduction ratio for next hits)
      };
      players.push(p);
      createUnitCard(p);
    }

    lblState.innerText = "å·²åˆå§‹åŒ–";
    lblTurn.innerText = "0";
  }

  // create unit card in battleArea
  function createUnitCard(p){
    const unit = document.createElement("div");
    unit.className = "unit";
    unit.id = `unit${p.id}`;
    // team color outline
    if (p.team === 1) unit.style.borderColor = "#4caf50";
    else if (p.team === 2) unit.style.borderColor = "#ff5722";
    else unit.style.borderColor = "#8e44ad";
    unit.innerHTML = `
      <div class="avatar">${p.name}</div>
      <div class="name">${p.name}</div>
      <div class="meta">T${p.team} | MAG:${p.magicIndex}</div>
      <div class="hpbar"><i id="hpInner${p.id}" style="width:100%"></i></div>
      <div class="buff-circle" id="buff${p.id}" style="display:none"></div>
    `;
    battleArea.appendChild(unit);
  }

  // ----------------------------
  // Skills
  // ----------------------------
  const SKILLS = [
    { key: "fire", name: "ç«çƒ", multiplier: 1.2, color: "fire", desc: "ç©©å®šå‚·å®³" },
    { key: "ice", name: "å†°ç®­", multiplier: 1.0, color: "ice", desc: "å‚·å®³ + æœ‰æ©Ÿç‡æ¸›é€Ÿ1å›åˆ" },
    { key: "thunder", name: "é›·æ“Š", multiplier: 1.45, color: "thunder", desc: "é«˜å‚·å®³ï¼Œæœ‰æ©Ÿç‡é€£é–å°ç¯„åœ" }
  ];

  function chooseSkillFor(attacker){
    // å¯æ”¹æ›ç‚ºç©å®¶é¸æ“‡ï¼›ç›®å‰ç°¡å–®éš¨æ©Ÿåå¥½é«˜é­”åŠ›é¸é›·æ“Š
    const roll = Math.random();
    if(attacker.magicIndex > 140 && roll < 0.5) return SKILLS[2];
    if(roll < 0.45) return SKILLS[0];
    if(roll < 0.8) return SKILLS[1];
    return SKILLS[0];
  }

  // ----------------------------
  // target selection
  // ----------------------------
  function chooseTarget(attacker){
    const aliveEnemies = players.filter(p => p.alive && p.team !== attacker.team);
    if(aliveEnemies.length === 0) return null;
    const strategy = strategySelect.value || "random";
    if(strategy === "random"){
      return aliveEnemies[Math.floor(Math.random() * aliveEnemies.length)];
    } else if(strategy === "lowestHP"){
      return aliveEnemies.sort((a,b)=> (a.hp/a.maxHP) - (b.hp/b.maxHP))[0];
    } else if(strategy === "highestThreat"){
      return aliveEnemies.sort((a,b)=> (b.ATK*(1+b.CRI)) - (a.ATK*(1+a.CRI)))[0];
    }
    return aliveEnemies[Math.floor(Math.random() * aliveEnemies.length)];
  }

  // ----------------------------
  // damage calc (balanced)
  // ----------------------------
  function computeDamage(attacker, defender, skill){
    // effective ATK with per-attack randomness
    const atkRandomFactor = 0.8 + Math.random()*0.4; // 0.8~1.2
    const defRandomFactor = 0.9 + Math.random()*0.3; // 0.9~1.2

    // base damage source relates to attacker's ATK and skill multiplier
    let raw = attacker.ATK * skill.multiplier * atkRandomFactor;

    // defender effective defense
    const effectiveDef = defender.DEF * defRandomFactor;

    // underdog boost: if attacker weaker than defender, small boost to raw
    const underdogBoost = 1 + clamp((defender.magicIndex - attacker.magicIndex)/400, -0.15, 0.35);

    let damage = raw * underdogBoost - effectiveDef;

    // minimum floor to avoid 0 damage
    if(damage < Math.min(8, attacker.ATK*0.05)) damage = Math.min(8, attacker.ATK*0.05) + Math.random()*6;

    // crit
    let isCrit = false;
    if(Math.random() < attacker.CRI){
      damage *= 1.3; // moderate crit
      isCrit = true;
    }

    // defender shield buff reduces damage (shield is ratio like 0.25)
    if(defender.buffs && defender.buffs.shield && defender.buffs.shield > 0){
      const shield = defender.buffs.shield;
      damage = Math.floor(damage * (1 - shield));
      // shield applies once per hit (optionally consume or keep for short duration)
    }

    damage = Math.max(1, Math.floor(damage));
    return { damage, isCrit };
  }

  // ----------------------------
  // Animations: magic shot, float text, aoe flash
  // ----------------------------
  function getUnitCenter(unitEl){
    const r = unitEl.getBoundingClientRect();
    const parentR = battleArea.getBoundingClientRect();
    return { x: r.left + r.width/2 - parentR.left, y: r.top + r.height/2 - parentR.top };
  }

  function spawnMagicShot(fromEl, toEl, type = "fire"){
    const start = getUnitCenter(fromEl);
    const end = getUnitCenter(toEl);
    const shot = document.createElement("div");
    shot.className = `magic-shot ${type}`;
    shot.style.left = `${start.x - 8}px`;
    shot.style.top = `${start.y - 8}px`;
    battleArea.appendChild(shot);

    // animate using CSS transform (compute delta)
    const dx = end.x - start.x;
    const dy = end.y - start.y;
    shot.style.transition = "transform 0.28s linear, opacity 0.28s linear";
    shot.style.transform = `translate(${dx}px, ${dy}px) scale(1)`;
    shot.classList.add("fly");

    setTimeout(() => {
      // impact effect
      shot.style.opacity = "0";
      setTimeout(()=> shot.remove(), 350);
    }, 300);
  }

  function showFloatText(x, y, text, styleClass = "") {
    const f = document.createElement("div");
    f.className = `float-text ${styleClass}`;
    f.style.left = `${x}px`;
    f.style.top = `${y}px`;
    f.innerText = text;
    battleArea.appendChild(f);
    setTimeout(()=> f.remove(), 900);
  }

  function aoeFlash(){
    const el = document.createElement("div");
    el.className = "aoe-flash";
    battleArea.appendChild(el);
    setTimeout(()=> el.remove(), 500);
  }

  // ----------------------------
  // Battle turn and loop
  // ----------------------------
  function startBattle(){
    if (running) return;
    if (playerCount < 2) { alert("è‡³å°‘éœ€è¦ 2 åç©å®¶"); return; }

    initPlayersFromUI();
    currentTurn = 0;
    running = true;
    lblState.innerText = "æˆ°é¬¥ä¸­";
    logBox.innerHTML = `<div>[${now()}] æˆ°é¬¥é–‹å§‹ï¼</div>`;
    // update maxTurns from input
    const maxTurns = Number(maxTurnsInput.value) || 50;

    simInterval = setInterval(() => {
      if(!running) return;
      currentTurn++;
      lblTurn.innerText = String(currentTurn);
      if(currentTurn > maxTurns){
        logBox.innerHTML += `<div>[${now()}] é”å›åˆä¸Šé™ï¼Œå¹³æ‰‹ã€‚</div>`;
        stopBattle();
        showStats();
        return;
      }

      // get alive list
      const living = players.filter(p => p.alive);
      const aliveTeams = [...new Set(living.map(p=>p.team))];
      if(aliveTeams.length <= 1){
        if(aliveTeams.length === 1) logBox.innerHTML += `<div>[${now()}] éšŠä¼ ${aliveTeams[0]} ç²å‹ï¼</div>`;
        else logBox.innerHTML += `<div>[${now()}] ç„¡äººç”Ÿé‚„ï¼Œå…¨æ»…ï¼</div>`;
        stopBattle();
        showStats();
        return;
      }

      // choose actor: highest effective SPD this tick (add small randomness to avoid same always)
      living.sort((a,b) => {
        const aEff = (a.SPD * (a.debuffs.slowTurns > 0 ? 0.6 : 1)) * rand(0.92,1.08);
        const bEff = (b.SPD * (b.debuffs.slowTurns > 0 ? 0.6 : 1)) * rand(0.92,1.08);
        return bEff - aEff;
      });

      // We'll process up to N actions per tick to keep pace: process 1 action per interval for clearer animation
const actor = living[Math.floor(Math.random()*living.length)];
      actor.actions++;
      if(actor.debuffs.slowTurns > 0) actor.debuffs.slowTurns--;

      // choose target and skill
      const target = chooseTarget(actor);
      if(!target){
        // no enemies left - handled above but safe
        return;
      }
      const skill = chooseSkillFor(actor);

      // attack animation
      const atkEl = document.getElementById(`unit${actor.id}`);
      const defEl = document.getElementById(`unit${target.id}`);

      // spawn shot
      spawnMagicShot(atkEl, defEl, skill.color);

      // compute damage (delayed to sync with shot)
      setTimeout(()=> {
        // check evasion
        if(Math.random() < target.EVA){
          // miss
          const c = getUnitCenter(defEl);
          showFloatText(c.x-10, c.y-10, "MISS", "miss");
          logBox.innerHTML += `<div>[${now()}] ${actor.name} çš„ ${skill.name} æœªå‘½ä¸­ ${target.name}ï¼ˆé–ƒé¿ï¼‰</div>`;
          target.hitsReceived++;
          updateUnitUI(target);
          return;
        }

        const { damage, isCrit } = computeDamage(actor, target, skill);
        // apply damage
        target.hp -= damage;
        actor.totalDamage += damage;
        if(isCrit) actor.critCount++;

        // skill side effects
        if(skill.key === "ice"){
          if(Math.random() < 0.32){
            // slow target 1 turn
            target.debuffs.slowTurns = Math.max(target.debuffs.slowTurns, 1);
            document.getElementById(`buff${target.id}`).style.display = "block";
            setTimeout(()=> { document.getElementById(`buff${target.id}`).style.display = "none"; }, 900);
            logBox.innerHTML += `<div>[${now()}] ${actor.name} çš„ å†°ç®­ å†°å‡äº† ${target.name}ï¼ˆä¸‹ä¸€å›åˆé€Ÿåº¦é™ä½ï¼‰</div>`;
          }
        } else if(skill.key === "thunder"){
          // chance to chain small AOE to another random enemy
          if(Math.random() < 0.28){
            const other = players.filter(p=>p.alive && p.team !== actor.team && p.id !== target.id);
            if(other.length){
              const extra = other[Math.floor(Math.random()*other.length)];
              const chainDmg = Math.max(2, Math.floor(damage * 0.4));
              extra.hp -= chainDmg;
              extra.hitsReceived++;
              // chain shot
              const extraEl = document.getElementById(`unit${extra.id}`);
              spawnMagicShot(defEl, extraEl, "thunder");
              const c2 = getUnitCenter(extraEl);
              showFloatText(c2.x-10, c2.y-10, `-${chainDmg}`, "");
              logBox.innerHTML += `<div>[${now()}] é›·æ“Šé€£é–å‘½ä¸­ ${extra.name} -${chainDmg}</div>`;
              if(extra.hp <= 0 && extra.alive){
                extra.alive = false;
                logBox.innerHTML += `<div>[${now()}] ğŸ’€ ${extra.name} è¢«é›·æ“Šé€£é–æ“Šå€’ï¼</div>`;
              }
              updateUnitUI(extra);
            }
          }
        }

        // show damage float at target
        const c = getUnitCenter(defEl);
        showFloatText(c.x-10, c.y-10, `-${damage}${isCrit ? " CRIT!" : ""}`, isCrit ? "crit" : "");

        // update stats & check death
        target.hitsReceived++;
        if(target.hp <= 0 && target.alive){
          target.alive = false;
          // death flash:
          defEl.classList.add("hit");
          setTimeout(()=> defEl.classList.remove("hit"), 400);
          logBox.innerHTML += `<div>[${now()}] ğŸ’€ ${target.name} è¢«æ“Šå€’ï¼</div>`;
        } else {
          // hit flash
          defEl.classList.add("hit");
          setTimeout(()=> defEl.classList.remove("hit"), 180);
        }

        // update UI
        updateUnitUI(target);
        updateUnitUI(actor);

        // append action log
        logBox.innerHTML += `<div>[${now()}] ${actor.name} ä½¿ç”¨ ${skill.name} æ”»æ“Š ${target.name} -${damage} ${isCrit ? "(çˆ†æ“Š)" : ""}</div>`;
        // auto-scroll
        logBox.scrollTop = logBox.scrollHeight;

        // small AOE flash for thunder crits
        if(skill.key === "thunder" && isCrit) aoeFlash();

        // check overall victory
        const aliveNow = players.filter(p=>p.alive);
        const aliveTeams = [...new Set(aliveNow.map(p=>p.team))];
        if(aliveTeams.length <= 1){
          if(aliveTeams.length === 1) logBox.innerHTML += `<div>[${now()}] éšŠä¼ ${aliveTeams[0]} ç²å‹ï¼</div>`;
          else logBox.innerHTML += `<div>[${now()}] å…¨æ»…ï¼</div>`;
          stopBattle();
          showStats();
          return;
        }

      }, 260); // damage applied after shot animation

      // after actor performed, rotate order next tick
    }, 650); // main loop tick (one action per tick for visual clarity)
  }

  function stopBattle(){
    if(simInterval) clearInterval(simInterval);
    simInterval = null;
    running = false;
    lblState.innerText = "å·²åœæ­¢";
  }

  // ----------------------------
  // UI updates
  // ----------------------------
  function updateUnitUI(p){
    const hpInner = document.getElementById(`hpInner${p.id}`);
    if(!hpInner) return;
    const pct = Math.max(0, (p.hp / p.maxHP) * 100);
    hpInner.style.width = `${pct}%`;
    const unitEl = document.getElementById(`unit${p.id}`);
    if(unitEl){
      const meta = unitEl.querySelector(".meta");
      if(meta) meta.innerText = `T${p.team} | HP:${Math.max(0,p.hp)}/${p.maxHP}`;
    }
  }

  function showStats(){
    let html = "<h4 style='margin-top:0'>æˆ°é¬¥çµ±è¨ˆ</h4>";
    html += `<div>å›åˆï¼š${currentTurn}</div>`;
    html += "<table border='0' style='margin:8px auto; color:#fff'><tr><th style='padding:6px'>ç©å®¶</th><th>éšŠä¼</th><th>é€ æˆ</th><th>çˆ†æ“Š</th><th>è¢«æ“Š</th><th>å­˜æ´»</th></tr>";
    players.forEach(p=>{
      html += `<tr><td style='padding:6px'>${p.name}</td><td>${p.team}</td><td>${p.totalDamage}</td><td>${p.critCount}</td><td>${p.hitsReceived}</td><td>${p.alive ? "å­˜æ´»":"æ­»äº¡"}</td></tr>`;
    });
    html += "</table>";
    statBox.innerHTML = html;
  }

  // ----------------------------
  // wire buttons
  // ----------------------------
  if(btnAdd) btnAdd.addEventListener("click", ()=>{ addPlayer(); });
  if(btnRemove) btnRemove.addEventListener("click", ()=>{ removePlayer(); });
  if(btnStart) btnStart.addEventListener("click", ()=>{ startBattle(); });

  // create initial demo players (keeps part1 behavior)
  for(let i=0;i<4;i++) addPlayer();

  // expose stopBattle to global if needed
  window.stopBattle = stopBattle;

  // expose startBattle for console
  window.startBattle = startBattle;
})();


</script>
</body>
</html>

